 CVE‑2024‑42461 Engine – src/engines/cve42461.ts
Goal: given a library verify function, and a canonical (msgHash, sigDER, pubkey), generate BER/DER variants and see which ones are accepted.

// src/engines/cve42461.ts
import { generateCveStyleVariants } from "./malleabilityPlayground";
import type { LibraryVerifyFn } from "../integrations/ellipticAdapter";

export type CveEncodingType =
  | "canonical"
  | "BER-padding-r"
  | "BER-padding-s"
  | "BER-padding-both"
  | "BER-length-mismatch"
  | "wrong-seq-tag"
  | "trailing-garbage";

export interface Cve42461TestCase {
  id: string;
  encodingType: CveEncodingType;
  derHex: string;        // DER+SIGHASH or just DER, up to you
  shouldVerify: boolean; // canonical should, others should NOT
  didVerify?: boolean;
  error?: string;
}

export interface Cve42461Report {
  libraryName: string;
  curve: string;
  acceptsCanonicalDER: boolean;
  acceptsBERVariants: boolean;
  vulnerable: boolean;
  testCases: Cve42461TestCase[];
}

/**
 * High‑level engine: test one “verify” implementation
 */
export async function runCve42461Suite(params: {
  libraryName: string;
  curve: string; // e.g. "secp256k1"
  msgHashHex: string; // 32 bytes hex
  canonicalDerHex: string; // DER (with or without sighash byte, but consistent)
  pubkeyHex: string;
  verifyFn: LibraryVerifyFn;
}): Promise<Cve42461Report> {
  const {
    libraryName,
    curve,
    msgHashHex,
    canonicalDerHex,
    pubkeyHex,
    verifyFn,
  } = params;

  // 1) build variant set (canonical + BER variants)
  const variants = generateCveStyleVariants(canonicalDerHex);

  const testCases: Cve42461TestCase[] = [];

  for (const v of variants) {
    const tc: Cve42461TestCase = {
      id: v.id,
      encodingType: v.encodingType,
      derHex: v.derHex,
      shouldVerify: v.encodingType === "canonical",
    };

    try {
      const didVerify = await verifyFn({
        curve,
        msgHashHex,
        derHex: v.derHex,
        pubkeyHex,
      });
      tc.didVerify = didVerify;
    } catch (e: any) {
      tc.didVerify = false;
      tc.error = e.message || String(e);
    }

    testCases.push(tc);
  }

  const acceptsCanonicalDER =
    testCases.find((t) => t.encodingType === "canonical")?.didVerify ?? false;

  const acceptsBERVariants = testCases.some(
    (t) => t.encodingType !== "canonical" && t.didVerify
  );

  return {
    libraryName,
    curve,
    acceptsCanonicalDER,
    acceptsBERVariants,
    vulnerable: acceptsBERVariants,
    testCases,
  };
}
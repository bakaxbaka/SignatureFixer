UI Panels – structure only (React)
6.1 CVE Panel – src/ui/Cve42461Panel.tsx
// src/ui/Cve42461Panel.tsx
import React, { useState } from "react";
import { runCve42461Suite } from "../engines/cve42461";
import { makeEllipticVerifyAdapter } from "../integrations/ellipticAdapter";
import { ec as EC } from "elliptic";

const secp = new EC("secp256k1"); // you can parameterize version

export const Cve42461Panel: React.FC = () => {
  const [libraryName, setLibraryName] = useState("elliptic@6.5.x");
  const [msgHashHex, setMsgHashHex] = useState("");
  const [derHex, setDerHex] = useState("");
  const [pubkeyHex, setPubkeyHex] = useState("");
  const [result, setResult] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleRun() {
    setError(null);
    setResult(null);

    if (!msgHashHex || !derHex || !pubkeyHex) {
      setError("Fill msg hash, DER signature, and pubkey.");
      return;
    }

    try {
      setLoading(true);
      const verifyFn = makeEllipticVerifyAdapter(secp);
      const report = await runCve42461Suite({
        libraryName,
        curve: "secp256k1",
        msgHashHex: msgHashHex.trim(),
        canonicalDerHex: derHex.trim(),
        pubkeyHex: pubkeyHex.trim(),
        verifyFn,
      });
      setResult(report);
    } catch (e: any) {
      setError(e.message || "Error running CVE suite");
    } finally {
      setLoading(false);
    }
  }

  return (
    <section>
      <h2>CVE‑2024‑42461 Library Check</h2>
      <div>
        <label>Library</label>
        <select
          value={libraryName}
          onChange={(e) => setLibraryName(e.target.value)}
        >
          <option value="elliptic@6.5.x">elliptic@6.5.x</option>
          {/* Add others: noble, bitcoinjs, HW wallet, etc. */}
        </select>
      </div>

      <div>
        <label>Message Hash (hex)</label>
        <input
          value={msgHashHex}
          onChange={(e) => setMsgHashHex(e.target.value)}
          placeholder="32-byte SHA256 or double-SHA256 hash"
        />
      </div>
      <div>
        <label>Canonical DER Signature (hex)</label>
        <textarea
          rows={3}
          value={derHex}
          onChange={(e) => setDerHex(e.target.value)}
        />
      </div>
      <div>
        <label>Public Key (hex, compressed)</label>
        <input
          value={pubkeyHex}
          onChange={(e) => setPubkeyHex(e.target.value)}
        />
      </div>

      <button disabled={loading} onClick={handleRun}>
        {loading ? "Running tests…" : "Run BER/DER Tests"}
      </button>

      {error && <div className="error">{error}</div>}

      {result && (
        <div className="report">
          <h3>Result for {result.libraryName}</h3>
          <p>
            Canonical accepted:{" "}
            {result.acceptsCanonicalDER ? "✅" : "❌ (broken implementation)"}
          </p>
          <p>
            Non-canonical BER accepted:{" "}
            {result.acceptsBERVariants ? "❌ vulnerable" : "✅ safe"}
          </p>

          <table>
            <thead>
              <tr>
                <th>Id</th>
                <th>Encoding</th>
                <th>Should verify</th>
                <th>Did verify</th>
                <th>Error</th>
              </tr>
            </thead>
            <tbody>
              {result.testCases.map((tc: any) => (
                <tr key={tc.id}>
                  <td>{tc.id}</td>
                  <td>{tc.encodingType}</td>
                  <td>{String(tc.shouldVerify)}</td>
                  <td>{String(tc.didVerify)}</td>
                  <td>{tc.error || ""}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </section>
  );
};
6.2 Wycheproof Lab – src/ui/WycheproofLab.tsx
Skeleton; you’ll wire actual JSON loading via API or bundling.

// src/ui/WycheproofLab.tsx
import React, { useState } from "react";
import { runWycheproofSuite } from "../engines/wycheproofRunner";
import { makeEllipticVerifyAdapter } from "../integrations/ellipticAdapter";
import { ec as EC } from "elliptic";

const secp = new EC("secp256k1");

export const WycheproofLab: React.FC = () => {
  const [curve, setCurve] = useState<"secp256k1" | "secp521r1">("secp256k1");
  const [libraryName, setLibraryName] = useState("elliptic");
  const [filterMode, setFilterMode] =
    useState<"all" | "edge">("edge");
  const [summary, setSummary] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleRun() {
    setError(null);
    setSummary(null);

    try {
      setLoading(true);

      // TODO: fetch or import JSON for chosen curve
      // const json = await fetch(`/wycheproof/${curve}.json`).then(r => r.json());
      const json = {}; // placeholder
      const { mapRawWycheproofJson } = await import(
        "../engines/wycheproofRunner"
      );
      const cases = mapRawWycheproofJson(json, curve);

      const verifyFn = makeEllipticVerifyAdapter(secp);

      const summaryResult = await runWycheproofSuite(cases, {
        curve,
        libraryName,
        verifyFn,
        filter:
          filterMode === "edge"
            ? (tc) => tc.flags.length > 0
            : undefined,
      });

      setSummary(summaryResult);
    } catch (e: any) {
      setError(e.message || "Wycheproof run failed");
    } finally {
      setLoading(false);
    }
  }

  return (
    <section>
      <h2>Wycheproof Test Lab</h2>
      <div>
        <label>Curve</label>
        <select
          value={curve}
          onChange={(e) =>
            setCurve(e.target.value as "secp256k1" | "secp521r1")
          }
        >
          <option value="secp256k1">secp256k1 (Bitcoin)</option>
          <option value="secp521r1">secp521r1</option>
        </select>
      </div>

      <div>
        <label>Library</label>
        <select
          value={libraryName}
          onChange={(e) => setLibraryName(e.target.value)}
        >
          <option value="elliptic">elliptic</option>
          {/* add more */}
        </select>
      </div>

      <div>
        <label>Cases</label>
        <select
          value={filterMode}
          onChange={(e) => setFilterMode(e.target.value as any)}
        >
          <option value="all">All test vectors</option>
          <option value="edge">Only edge-case / malformed</option>
        </select>
      </div>

      <button disabled={loading} onClick={handleRun}>
        {loading ? "Running Wycheproof…" : "Run Wycheproof Suite"}
      </button>

      {error && <div className="error">{error}</div>}

      {summary && (
        <div>
          <h3>
            {summary.libraryName} on {summary.curve}
          </h3>
          <p>
            Passed {summary.passed} / {summary.total}, failed{" "}
            {summary.failed}
          </p>

          {summary.mismatches.length > 0 && (
            <>
              <h4>Mismatches</h4>
              <table>
                <thead>
                  <tr>
                    <th>tcId</th>
                    <th>Expected</th>
                    <th>Lib Accepts</th>
                    <th>Parser Accepts</th>
                    <th>Flags</th>
                    <th>DER Issues</th>
                  </tr>
                </thead>
                <tbody>
                  {summary.mismatches.map((m: any) => (
                    <tr key={m.tcId}>
                      <td>{m.tcId}</td>
                      <td>{m.expected}</td>
                      <td>{String(m.libraryAccepts)}</td>
                      <td>{String(m.parserAccepts)}</td>
                      <td>{m.flags.join(", ")}</td>
                      <td>{m.derIssues.join("; ")}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </>
          )}
        </div>
      )}
    </section>
  );
};

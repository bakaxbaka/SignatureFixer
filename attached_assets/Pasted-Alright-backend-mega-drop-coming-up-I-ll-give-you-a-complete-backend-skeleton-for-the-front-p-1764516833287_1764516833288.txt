Alright, backend mega‚Äëdrop coming up üöÄ

I‚Äôll give you a complete backend skeleton for the front‚Äëpage Raw Tx Inspector, wired around:

POST /api/inspect-tx

Services:

txDecode.ts

utxoFetcher.ts

script.ts

signature.ts

sighash.ts

der.ts

Types: txInspector.ts

Express route: inspectTxRoute.ts

You can then plug it into your existing project and replace the stubbed parts (multi‚Äëendpoint fetcher, network config, etc).

0. Types ‚Äì src/types/txInspector.ts
// src/types/txInspector.ts

export type NetworkName = "mainnet" | "testnet" | "signet" | "regtest";

export type ScriptType =
  | "p2pkh"
  | "p2wpkh"
  | "p2sh"
  | "p2sh-p2wpkh"
  | "p2tr"
  | "nulldata"
  | "unknown";

export type SighashTypeName =
  | "SIGHASH_ALL"
  | "SIGHASH_NONE"
  | "SIGHASH_SINGLE"
  | "SIGHASH_ALL|ANYONECANPAY"
  | "SIGHASH_NONE|ANYONECANPAY"
  | "SIGHASH_SINGLE|ANYONECANPAY"
  | "UNKNOWN";

export interface SignatureDerIssue {
  code:
    | "NON_CANONICAL"
    | "EXTRA_PADDING_R"
    | "EXTRA_PADDING_S"
    | "BAD_SEQ_TAG"
    | "BAD_LENGTH"
    | "TRAILING_GARBAGE"
    | "OUT_OF_RANGE_R"
    | "OUT_OF_RANGE_S";
  message: string;
}

export interface SignatureAnalysis {
  derHex: string;
  rHex: string;
  sHex: string;
  zHex: string;
  sighashType: number;
  sighashName: SighashTypeName;
  pubkeyHex?: string;
  isHighS: boolean;
  isCanonicalDer: boolean;
  rangeValid: boolean;
  derIssues: SignatureDerIssue[];
  warnings: string[];
}

export interface TxInputAnalysis {
  index: number;
  prevTxid: string;
  prevVout: number;
  sequence: number;
  scriptSigHex?: string;
  scriptSigAsm?: string;
  witness?: string[];
  scriptType: ScriptType;
  valueSats?: number;
  address?: string;
  isCoinbase: boolean;
  pubkeyHex?: string;
  signature?: SignatureAnalysis | null;
  samePubkeyAsInputs?: number[];
}

export interface TxOutputAnalysis {
  index: number;
  valueSats: number;
  scriptPubKeyHex: string;
  scriptPubKeyAsm?: string;
  scriptType: ScriptType;
  address?: string;
  isChangeGuess: boolean;
}

export interface SummaryFlags {
  hasHighS: boolean;
  hasNonCanonicalDer: boolean;
  hasWeirdSighash: boolean;
  hasRangeViolations: boolean;
  hasMultiInputSameKey: boolean;
  hasRReuseWithinTx: boolean;
}

export interface InspectTxRequest {
  rawTxHex?: string;
  txid?: string;
}

export interface InspectTxResponse {
  ok: boolean;
  error?: string;

  network?: NetworkName;
  txid?: string;
  rawTxHex?: string;

  version?: number;
  locktime?: number;
  sizeBytes?: number;
  vsizeBytes?: number;
  weight?: number;

  totalInputSats?: number;
  totalOutputSats?: number;
  feeSats?: number;
  feeRateSatPerVbyte?: number;

  inputs?: TxInputAnalysis[];
  outputs?: TxOutputAnalysis[];
  summaryFlags?: SummaryFlags;
}
1. Network config ‚Äì src/config/network.ts
// src/config/network.ts
import type { NetworkName } from "../types/txInspector";
import { networks, Network } from "bitcoinjs-lib";

export const NETWORK: NetworkName = "mainnet";

export function getBitcoinJsNetwork(): Network {
  switch (NETWORK) {
    case "testnet":
      return networks.testnet;
    case "regtest":
      return networks.regtest;
    case "signet":
      // signet often uses testnet params in bitcoinjs
      return networks.testnet;
    case "mainnet":
    default:
      return networks.bitcoin;
  }
}
2. TX decoder ‚Äì src/services/txDecode.ts
Using bitcoinjs-lib for sanity:

// src/services/txDecode.ts
import { Transaction } from "bitcoinjs-lib";
import type { TxInputAnalysis, TxOutputAnalysis } from "../types/txInspector";

export interface DecodedTx {
  txid: string;
  version: number;
  locktime: number;
  sizeBytes: number;
  vsizeBytes: number;
  weight: number;
  inputs: TxInputAnalysis[];
  outputs: TxOutputAnalysis[];
}

export function decodeRawTx(rawTxHex: string): DecodedTx {
  const buf = Buffer.from(rawTxHex, "hex");
  const tx = Transaction.fromBuffer(buf);

  const inputs: TxInputAnalysis[] = tx.ins.map((input, index) => {
    const prevTxid = Buffer.from(input.hash).reverse().toString("hex");
    const prevVout = input.index;
    const scriptSigHex = input.script?.toString("hex") || "";
    const isCoinbase = prevTxid === "0".repeat(64);

    return {
      index,
      prevTxid,
      prevVout,
      sequence: input.sequence,
      scriptSigHex,
      scriptSigAsm: "", // you can later add ASM formatter
      witness: input.witness?.map((w) => w.toString("hex")) || [],
      scriptType: "unknown", // will be set later
      valueSats: undefined,
      address: undefined,
      isCoinbase,
      pubkeyHex: undefined,
      signature: null,
      samePubkeyAsInputs: [],
    };
  });

  const outputs: TxOutputAnalysis[] = tx.outs.map((out, index) => ({
    index,
    valueSats: out.value,
    scriptPubKeyHex: out.script.toString("hex"),
    scriptPubKeyAsm: "",
    scriptType: "unknown",
    address: undefined,
    isChangeGuess: false,
  }));

  return {
    txid: tx.getId(),
    version: tx.version,
    locktime: tx.locktime,
    sizeBytes: buf.length,
    vsizeBytes: tx.virtualSize(),
    weight: tx.weight(),
    inputs,
    outputs,
  };
}
3. UTXO fetcher ‚Äì src/services/utxoFetcher.ts
Skeleton with pluggable backends (you can replace with your existing BitcoinService):

// src/services/utxoFetcher.ts
import type { TxOutputAnalysis } from "../types/txInspector";
import { decodeRawTx, DecodedTx } from "./txDecode";

// naive in-memory cache
const txCache = new Map<string, DecodedTx>();

export async function fetchPrevTx(txid: string): Promise<DecodedTx | null> {
  if (txCache.has(txid)) return txCache.get(txid)!;

  const raw = await fetchRawTxByTxid(txid);
  if (!raw) return null;

  const decoded = decodeRawTx(raw);
  txCache.set(txid, decoded);
  return decoded;
}

// TODO: wire with your multi-endpoint + Tor + rate-limit-aware fetcher
export async function fetchRawTxByTxid(txid: string): Promise<string | null> {
  // This is a stub. Replace with your actual implementation.
  // For example, call blockstream.info / mempool.space / your node.
  console.warn("fetchRawTxByTxid: stub called for", txid);
  return null;
}

export function buildPrevOutput(
  prevTx: DecodedTx,
  vout: number
): { valueSats: number; scriptPubKeyHex: string } | null {
  const out = prevTx.outputs[vout];
  if (!out) return null;
  return {
    valueSats: out.valueSats,
    scriptPubKeyHex: out.scriptPubKeyHex,
  };
}
4. Script classification ‚Äì src/services/script.ts
Simple scriptType + address decoding using bitcoinjs-lib:

// src/services/script.ts
import { payments, script as bscript } from "bitcoinjs-lib";
import type { ScriptType, NetworkName } from "../types/txInspector";
import { getBitcoinJsNetwork } from "../config/network";

export function classifyScriptPubKey(scriptHex: string): ScriptType {
  const buf = Buffer.from(scriptHex, "hex");

  // P2PKH: OP_DUP OP_HASH160 PUSH20 <20B> OP_EQUALVERIFY OP_CHECKSIG
  if (
    buf.length === 25 &&
    buf[0] === 0x76 &&
    buf[1] === 0xa9 &&
    buf[2] === 0x14 &&
    buf[23] === 0x88 &&
    buf[24] === 0xac
  ) {
    return "p2pkh";
  }

  // P2WPKH: 0x00 0x14 <20B>
  if (buf.length === 22 && buf[0] === 0x00 && buf[1] === 0x14) {
    return "p2wpkh";
  }

  // P2SH: OP_HASH160 PUSH20 <20B> OP_EQUAL
  if (
    buf.length === 23 &&
    buf[0] === 0xa9 &&
    buf[1] === 0x14 &&
    buf[22] === 0x87
  ) {
    return "p2sh";
  }

  // Data (OP_RETURN)
  if (buf.length > 0 && buf[0] === 0x6a) {
    return "nulldata";
  }

  return "unknown";
}

export function decodeAddressFromScript(
  scriptHex: string,
  networkName: NetworkName
): string | undefined {
  const network = getBitcoinJsNetwork();
  const buf = Buffer.from(scriptHex, "hex");

  try {
    // Try P2PKH
    if (classifyScriptPubKey(scriptHex) === "p2pkh") {
      const payment = payments.p2pkh({ output: buf, network });
      return payment.address;
    }
    // Try P2WPKH
    if (classifyScriptPubKey(scriptHex) === "p2wpkh") {
      const payment = payments.p2wpkh({ output: buf, network });
      return payment.address;
    }
    // Try P2SH
    if (classifyScriptPubKey(scriptHex) === "p2sh") {
      const payment = payments.p2sh({ output: buf, network });
      return payment.address;
    }
  } catch (e) {
    console.warn("decodeAddressFromScript error", e);
  }

  return undefined;
}
5. DER parsing & analysis ‚Äì src/services/der.ts
Basic strictish DER parser + high‚ÄëS / range detection for secp256k1:

// src/services/der.ts
import { ECPairFactory } from "ecpair";
import * as secp256k1 from "tiny-secp256k1";
import type {
  SignatureDerIssue,
  SighashTypeName,
} from "../types/txInspector";

const curveN = BigInt(
  "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
);
const halfN = curveN >> 1n;

export interface DerAnalysisResult {
  rHex: string;
  sHex: string;
  sighashName: SighashTypeName;
  isHighS: boolean;
  isCanonical: boolean;
  rangeValid: boolean;
  derIssues: SignatureDerIssue[];
  warnings: string[];
}

export function analyzeDerSignature(
  derHex: string,
  sighashType?: number
): DerAnalysisResult {
  const issues: SignatureDerIssue[] = [];
  const warnings: string[] = [];

  let rHex = "";
  let sHex = "";
  let isCanonical = true;
  let rangeValid = true;
  let isHighS = false;

  try {
    const buf = Buffer.from(derHex, "hex");

    // 1) optional last byte as sighash
    let sig = buf;
    if (sighashType === undefined && buf.length > 0) {
      // guess sighash = last byte
      sighashType = buf[buf.length - 1];
      sig = buf.slice(0, -1);
    } else if (sighashType !== undefined && buf.length > 0) {
      sig = buf.slice(0, -1);
    }

    if (sig[0] !== 0x30) {
      isCanonical = false;
      issues.push({
        code: "BAD_SEQ_TAG",
        message: "Signature does not start with SEQUENCE (0x30)",
      });
    }

    const totalLen = sig[1];
    if (totalLen + 2 !== sig.length) {
      isCanonical = false;
      issues.push({
        code: "BAD_LENGTH",
        message: "SEQUENCE length does not match actual length",
      });
    }

    // parse R
    let offset = 2;
    if (sig[offset] !== 0x02) {
      isCanonical = false;
      issues.push({
        code: "BAD_LENGTH",
        message: "R integer does not start with 0x02",
      });
    }
    offset++;
    const lenR = sig[offset++];
    const rBytes = sig.slice(offset, offset + lenR);
    offset += lenR;

    // parse S
    if (sig[offset] !== 0x02) {
      isCanonical = false;
      issues.push({
        code: "BAD_LENGTH",
        message: "S integer does not start with 0x02",
      });
    }
    offset++;
    const lenS = sig[offset++];
    const sBytes = sig.slice(offset, offset + lenS);
    offset += lenS;

    if (offset !== sig.length) {
      isCanonical = false;
      issues.push({
        code: "TRAILING_GARBAGE",
        message: "Extra data after S integer",
      });
    }

    // minimal encoding checks for R
    if (rBytes.length === 0 || (rBytes[0] === 0x00 && rBytes.length === 1)) {
      isCanonical = false;
    }
    if (rBytes.length > 1 && rBytes[0] === 0x00 && (rBytes[1] & 0x80) === 0) {
      isCanonical = false;
      issues.push({
        code: "EXTRA_PADDING_R",
        message: "Unnecessary leading zero in R",
      });
    }

    // same for S
    if (sBytes.length === 0 || (sBytes[0] === 0x00 && sBytes.length === 1)) {
      isCanonical = false;
    }
    if (sBytes.length > 1 && sBytes[0] === 0x00 && (sBytes[1] & 0x80) === 0) {
      isCanonical = false;
      issues.push({
        code: "EXTRA_PADDING_S",
        message: "Unnecessary leading zero in S",
      });
    }

    rHex = rBytes.toString("hex");
    sHex = sBytes.toString("hex");

    const r = BigInt("0x" + rHex);
    const s = BigInt("0x" + sHex);

    if (r <= 0n || r >= curveN) {
      rangeValid = false;
      issues.push({
        code: "OUT_OF_RANGE_R",
        message: "R not in [1, n-1]",
      });
    }
    if (s <= 0n || s >= curveN) {
      rangeValid = false;
      issues.push({
        code: "OUT_OF_RANGE_S",
        message: "S not in [1, n-1]",
      });
    }

    isHighS = s > halfN;
    if (isHighS) {
      warnings.push("High-S signature (non-canonical under BIP62 conventions)");
    }
  } catch (e: any) {
    isCanonical = false;
    warnings.push("Error parsing DER signature: " + e.message);
  }

  return {
    rHex,
    sHex,
    sighashName: classifySighashType(sighashType ?? 0x01),
    isHighS,
    isCanonical,
    rangeValid,
    derIssues: issues,
    warnings,
  };
}

export function classifySighashType(type: number): SighashTypeName {
  const base = type & 0x1f;
  const acp = (type & 0x80) !== 0;

  if (base === 0x01 && !acp) return "SIGHASH_ALL";
  if (base === 0x02 && !acp) return "SIGHASH_NONE";
  if (base === 0x03 && !acp) return "SIGHASH_SINGLE";
  if (base === 0x01 && acp) return "SIGHASH_ALL|ANYONECANPAY";
  if (base === 0x02 && acp) return "SIGHASH_NONE|ANYONECANPAY";
  if (base === 0x03 && acp) return "SIGHASH_SINGLE|ANYONECANPAY";
  return "UNKNOWN";
}
6. Signature extraction ‚Äì src/services/signature.ts
Handle P2PKH + P2WPKH basic cases:

// src/services/signature.ts
import type { TxInputAnalysis } from "../types/txInspector";
import { classifyScriptPubKey } from "./script";

export interface ExtractedSignature {
  derHex: string;
  pubkeyHex?: string;
  sighashType: number;
  prevOutputScriptHex: string;
  prevOutputValueSats: number;
}

export function extractInputSignature(
  inp: TxInputAnalysis
): ExtractedSignature | null {
  if (inp.isCoinbase) return null;

  // For this extractor we assume you've enriched inp.valueSats and inp.scriptType
  if (!inp.valueSats) return null;

  // P2PKH style in scriptSig: <PUSHDATA sig> <PUSHDATA pubkey>
  if (inp.scriptSigHex && inp.scriptSigHex.length > 0) {
    const buf = Buffer.from(inp.scriptSigHex, "hex");
    // naive parsing: first push = sig, second = pubkey
    let offset = 0;
    if (offset >= buf.length) return null;

    const sigLen = buf[offset];
    offset++;
    const sig = buf.slice(offset, offset + sigLen);
    offset += sigLen;

    const pubLen = buf[offset];
    offset++;
    const pub = buf.slice(offset, offset + pubLen);

    const sighashType = sig[sig.length - 1];
    const der = sig.slice(0, -1);

    // prevOutputScriptHex should come from the previous tx
    // for now we assume scriptType p2pkh and reconstruct from address
    // but better: store prevOutputScriptHex when enriching UTXO.
    const prevOutputScriptHexPlaceholder = ""; // fill from your UTXO enrichment

    return {
      derHex: der.toString("hex"),
      pubkeyHex: pub.toString("hex"),
      sighashType,
      prevOutputScriptHex: prevOutputScriptHexPlaceholder,
      prevOutputValueSats: inp.valueSats,
    };
  }

  // Native P2WPKH: sig + pubkey in witness
  if (inp.witness && inp.witness.length === 2) {
    const sigBuf = Buffer.from(inp.witness[0], "hex");
    const pubBuf = Buffer.from(inp.witness[1], "hex");
    const sighashType = sigBuf[sigBuf.length - 1];
    const der = sigBuf.slice(0, -1);

    // For segwit, prev output script is the scriptPubKey from previous tx
    const prevOutputScriptHexPlaceholder = ""; // same note as above

    return {
      derHex: der.toString("hex"),
      pubkeyHex: pubBuf.toString("hex"),
      sighashType,
      prevOutputScriptHex: prevOutputScriptHexPlaceholder,
      prevOutputValueSats: inp.valueSats,
    };
  }

  return null;
}
üîß Note: in your actual app you already know the prevOutputScriptHex from the UTXO fetch step; pass it through and fill in those placeholders.

7. Sighash computation ‚Äì src/services/sighash.ts
Using bitcoinjs-lib PSBT helper functions is easiest, but here‚Äôs a direct BIP143 + legacy style skeleton:

// src/services/sighash.ts
import { Transaction, crypto as bcrypto } from "bitcoinjs-lib";
import type { DecodedTx } from "./txDecode";

export interface SighashContext {
  rawTxHex: string;
  decodedTx: DecodedTx;
  inputIndex: number;
  sighashType: number;
  prevOutputScriptHex: string;
  prevOutputValueSats: number;
}

export function computeSighashZ(ctx: SighashContext): string {
  const { rawTxHex, inputIndex, sighashType } = ctx;
  const buf = Buffer.from(rawTxHex, "hex");
  const tx = Transaction.fromBuffer(buf);

  const hash = tx.hashForSignature(
    inputIndex,
    Buffer.from(ctx.prevOutputScriptHex, "hex"),
    sighashType
  );

  return hash.toString("hex");
}
üìù If you need full segwit BIP143 semantics with value + witness, use tx.hashForWitnessV0 instead, based on scriptType. You can branch:

// Example if you know it's P2WPKH:
const hash = tx.hashForWitnessV0(
  inputIndex,
  Buffer.from(scriptCode, "hex"),
  ctx.prevOutputValueSats,
  sighashType
);
For the first version, the legacy hashForSignature is fine for P2PKH examples.

8. Main inspect service ‚Äì src/services/inspectTx.ts
Putting it all together:

// src/services/inspectTx.ts
import {
  InspectTxRequest,
  InspectTxResponse,
} from "../types/txInspector";
import { decodeRawTx } from "./txDecode";
import { fetchPrevTx, buildPrevOutput } from "./utxoFetcher";
import { classifyScriptPubKey, decodeAddressFromScript } from "./script";
import { extractInputSignature } from "./signature";
import { computeSighashZ } from "./sighash";
import { analyzeDerSignature } from "./der";
import { NETWORK } from "../config/network";

export async function inspectTx(
  req: InspectTxRequest
): Promise<InspectTxResponse> {
  try {
    if (!req.txid && !req.rawTxHex) {
      return { ok: false, error: "txid or rawTxHex is required" };
    }

    let rawTxHex = req.rawTxHex?.trim();
    if (!rawTxHex && req.txid) {
      rawTxHex = await fetchRawTxByTxid(req.txid);
      if (!rawTxHex) {
        return { ok: false, error: "Could not fetch transaction by txid" };
      }
    }
    if (!rawTxHex) {
      return { ok: false, error: "Empty rawTxHex after fetch" };
    }

    const decoded = decodeRawTx(rawTxHex);

    // enrich inputs with UTXO info
    const enrichedInputs = await Promise.all(
      decoded.inputs.map(async (inp) => {
        if (inp.isCoinbase) return inp;

        const prevTx = await fetchPrevTx(inp.prevTxid);
        if (!prevTx) return inp;

        const prevOut = buildPrevOutput(prevTx, inp.prevVout);
        if (!prevOut) return inp;

        const scriptType = classifyScriptPubKey(prevOut.scriptPubKeyHex);
        const address = decodeAddressFromScript(
          prevOut.scriptPubKeyHex,
          NETWORK
        );

        return {
          ...inp,
          valueSats: prevOut.valueSats,
          scriptType,
          address,
          // store prevOutputScriptHex for sighash
          prevOutputScriptHex: prevOut.scriptPubKeyHex,
        } as any;
      })
    );

    // signatures
    const signatureAnalyses = await Promise.all(
      enrichedInputs.map(async (inp: any, index) => {
        if (inp.isCoinbase) return null;

        const sigInfo = extractInputSignature(inp);
        if (!sigInfo) return null;

        const { derHex, pubkeyHex, sighashType } = sigInfo;

        const zHex = computeSighashZ({
          rawTxHex,
          decodedTx: decoded,
          inputIndex: index,
          sighashType,
          prevOutputScriptHex:
            sigInfo.prevOutputScriptHex || inp.prevOutputScriptHex,
          prevOutputValueSats: sigInfo.prevOutputValueSats ?? inp.valueSats,
        });

        const derAnalysis = analyzeDerSignature(derHex, sighashType);

        return {
          derHex,
          rHex: derAnalysis.rHex,
          sHex: derAnalysis.sHex,
          zHex,
          sighashType,
          sighashName: derAnalysis.sighashName,
          pubkeyHex,
          isHighS: derAnalysis.isHighS,
          isCanonicalDer: derAnalysis.isCanonical,
          rangeValid: derAnalysis.rangeValid,
          derIssues: derAnalysis.derIssues,
          warnings: derAnalysis.warnings,
        };
      })
    );

    const finalInputs = enrichedInputs.map((inp: any, i: number) => ({
      ...inp,
      signature: signatureAnalyses[i],
    }));

    // outputs classification
    const finalOutputs = decoded.outputs.map((out) => {
      const scriptType = classifyScriptPubKey(out.scriptPubKeyHex);
      const address = decodeAddressFromScript(out.scriptPubKeyHex, NETWORK);
      return {
        ...out,
        scriptType,
        address,
      };
    });

    // totals
    const totalInputSats = finalInputs
      .map((i: any) => i.valueSats ?? 0)
      .reduce((a: number, b: number) => a + b, 0);
    const totalOutputSats = finalOutputs
      .map((o) => o.valueSats)
      .reduce((a, b) => a + b, 0);
    const feeSats =
      totalInputSats > 0 && totalOutputSats >= 0
        ? totalInputSats - totalOutputSats
        : undefined;
    const feeRateSatPerVbyte =
      feeSats != null && decoded.vsizeBytes
        ? feeSats / decoded.vsizeBytes
        : undefined;

    const summaryFlags = {
      hasHighS: signatureAnalyses.some((s) => s?.isHighS),
      hasNonCanonicalDer: signatureAnalyses.some(
        (s) => s && !s.isCanonicalDer
      ),
      hasWeirdSighash: signatureAnalyses.some(
        (s) => s && s.sighashName !== "SIGHASH_ALL"
      ),
      hasRangeViolations: signatureAnalyses.some(
        (s) => s && !s.rangeValid
      ),
      hasMultiInputSameKey: detectMultiInputSameKey(finalInputs as any[]),
      hasRReuseWithinTx: detectRReuseWithinTx(signatureAnalyses),
    };

    return {
      ok: true,
      network: NETWORK,
      txid: decoded.txid,
      rawTxHex,
      version: decoded.version,
      locktime: decoded.locktime,
      sizeBytes: decoded.sizeBytes,
      vsizeBytes: decoded.vsizeBytes,
      weight: decoded.weight,
      totalInputSats,
      totalOutputSats,
      feeSats,
      feeRateSatPerVbyte,
      inputs: finalInputs,
      outputs: finalOutputs,
      summaryFlags,
    };
  } catch (err: any) {
    console.error("inspectTx error:", err);
    return { ok: false, error: err.message || "Unexpected error in inspectTx" };
  }
}

function detectMultiInputSameKey(inputs: any[]): boolean {
  const map = new Map<string, number[]>();
  inputs.forEach((inp, idx) => {
    const pk = inp.signature?.pubkeyHex;
    if (!pk) return;
    const arr = map.get(pk) || [];
    arr.push(idx);
    map.set(pk, arr);
  });
  return Array.from(map.values()).some((arr) => arr.length > 1);
}

function detectRReuseWithinTx(sigs: (any | null)[]): boolean {
  const map = new Map<string, number[]>();
  sigs.forEach((s, idx) => {
    if (!s) return;
    const r = s.rHex;
    const arr = map.get(r) || [];
    arr.push(idx);
    map.set(r, arr);
  });
  return Array.from(map.values()).some((arr) => arr.length > 1);
}

// reuse from utxoFetcher
import { fetchRawTxByTxid } from "./utxoFetcher";
9. Express route ‚Äì src/routes/inspectTxRoute.ts
// src/routes/inspectTxRoute.ts
import type { Request, Response } from "express";
import { inspectTx } from "../services/inspectTx";

export async function inspectTxRoute(req: Request, res: Response) {
  try {
    const { rawTxHex, txid } = req.body || {};
    const result = await inspectTx({ rawTxHex, txid });
    res.json(result);
  } catch (err: any) {
    console.error("inspectTxRoute error:", err);
    res.status(500).json({
      ok: false,
      error: "Internal server error in /api/inspect-tx",
    });
  }
}
And wire it in your server:

// server/index.ts or server/routes.ts
import express from "express";
import { inspectTxRoute } from "./routes/inspectTxRoute";

const app = express();
app.use(express.json());

app.post("/api/inspect-tx", inspectTxRoute);

// ...other routes & app.listen(...)
That‚Äôs the full stack in one shot: types ‚Üí services ‚Üí sighash/DER/signature extraction ‚Üí route.
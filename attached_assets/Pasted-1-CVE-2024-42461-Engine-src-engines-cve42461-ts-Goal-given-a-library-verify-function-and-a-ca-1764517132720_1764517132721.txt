1️⃣ CVE‑2024‑42461 Engine – src/engines/cve42461.ts
Goal: given a library verify function, and a canonical (msgHash, sigDER, pubkey), generate BER/DER variants and see which ones are accepted.

// src/engines/cve42461.ts
import { generateCveStyleVariants } from "./malleabilityPlayground";
import type { LibraryVerifyFn } from "../integrations/ellipticAdapter";

export type CveEncodingType =
  | "canonical"
  | "BER-padding-r"
  | "BER-padding-s"
  | "BER-padding-both"
  | "BER-length-mismatch"
  | "wrong-seq-tag"
  | "trailing-garbage";

export interface Cve42461TestCase {
  id: string;
  encodingType: CveEncodingType;
  derHex: string;        // DER+SIGHASH or just DER, up to you
  shouldVerify: boolean; // canonical should, others should NOT
  didVerify?: boolean;
  error?: string;
}

export interface Cve42461Report {
  libraryName: string;
  curve: string;
  acceptsCanonicalDER: boolean;
  acceptsBERVariants: boolean;
  vulnerable: boolean;
  testCases: Cve42461TestCase[];
}

/**
 * High‑level engine: test one “verify” implementation
 */
export async function runCve42461Suite(params: {
  libraryName: string;
  curve: string; // e.g. "secp256k1"
  msgHashHex: string; // 32 bytes hex
  canonicalDerHex: string; // DER (with or without sighash byte, but consistent)
  pubkeyHex: string;
  verifyFn: LibraryVerifyFn;
}): Promise<Cve42461Report> {
  const {
    libraryName,
    curve,
    msgHashHex,
    canonicalDerHex,
    pubkeyHex,
    verifyFn,
  } = params;

  // 1) build variant set (canonical + BER variants)
  const variants = generateCveStyleVariants(canonicalDerHex);

  const testCases: Cve42461TestCase[] = [];

  for (const v of variants) {
    const tc: Cve42461TestCase = {
      id: v.id,
      encodingType: v.encodingType,
      derHex: v.derHex,
      shouldVerify: v.encodingType === "canonical",
    };

    try {
      const didVerify = await verifyFn({
        curve,
        msgHashHex,
        derHex: v.derHex,
        pubkeyHex,
      });
      tc.didVerify = didVerify;
    } catch (e: any) {
      tc.didVerify = false;
      tc.error = e.message || String(e);
    }

    testCases.push(tc);
  }

  const acceptsCanonicalDER =
    testCases.find((t) => t.encodingType === "canonical")?.didVerify ?? false;

  const acceptsBERVariants = testCases.some(
    (t) => t.encodingType !== "canonical" && t.didVerify
  );

  return {
    libraryName,
    curve,
    acceptsCanonicalDER,
    acceptsBERVariants,
    vulnerable: acceptsBERVariants,
    testCases,
  };
}
2️⃣ Wycheproof Engine – src/engines/wycheproofRunner.ts
Goal: run Wycheproof JSON vectors through your DER parser and any ECDSA verify function.

// src/engines/wycheproofRunner.ts
import type { LibraryVerifyFn } from "../integrations/ellipticAdapter";
import { analyzeDerStrict } from "../crypto/derStrict";

export type WycheproofResultKind = "valid" | "invalid" | "acceptable";

export interface WycheproofTestCase {
  tcId: number;
  comment: string;
  msgHex: string;
  sigHex: string;
  pubHex: string;
  result: WycheproofResultKind;
  flags: string[];
  curve: string;
}

export interface WycheproofCaseResult {
  tcId: number;
  comment: string;
  curve: string;
  expected: WycheproofResultKind;
  libraryAccepts: boolean;
  parserAccepts: boolean;
  flags: string[];
  derIssues: string[];
}

export interface WycheproofRunOptions {
  curve: string;          // "secp256k1", "secp521r1", ...
  libraryName: string;
  verifyFn: LibraryVerifyFn;
  // For performance, you may want to limit which test cases to run
  filter?: (tc: WycheproofTestCase) => boolean;
}

/**
 * Given parsed Wycheproof JSON, convert to internal representation.
 * You’ll call this after loading the JSON with fs.readFileSync + JSON.parse.
 */
export function mapRawWycheproofJson(json: any, curve: string): WycheproofTestCase[] {
  const groups = json.testGroups || [];
  const cases: WycheproofTestCase[] = [];

  for (const g of groups) {
    const pub = g.key?.uncompressed || g.key?.wx || g.key?.key || "";
    for (const t of g.tests || []) {
      cases.push({
        tcId: t.tcId,
        comment: t.comment || "",
        msgHex: t.msg || "",
        sigHex: t.sig || "",
        pubHex: pub,
        result: t.result,
        flags: t.flags || [],
        curve,
      });
    }
  }

  return cases;
}

export interface WycheproofRunSummary {
  libraryName: string;
  curve: string;
  total: number;
  passed: number;
  failed: number;
  mismatches: WycheproofCaseResult[];
}

export async function runWycheproofSuite(
  cases: WycheproofTestCase[],
  opts: WycheproofRunOptions
): Promise<WycheproofRunSummary> {
  const { verifyFn, libraryName, curve, filter } = opts;
  const filtered = filter ? cases.filter(filter) : cases;

  const mismatches: WycheproofCaseResult[] = [];
  let passed = 0;

  for (const tc of filtered) {
    const derStrict = analyzeDerStrict(tc.sigHex);
    const parserAccepts = derStrict.isCanonical && derStrict.rangeValid;
    let libraryAccepts = false;

    try {
      libraryAccepts = await verifyFn({
        curve,
        msgHashHex: tc.msgHex,
        derHex: tc.sigHex,
        pubkeyHex: tc.pubHex,
      });
    } catch {
      libraryAccepts = false;
    }

    const expected = tc.result; // "valid" | "invalid" | "acceptable"

    const isOk =
      (expected === "valid" && libraryAccepts) ||
      (expected === "invalid" && !libraryAccepts) ||
      (expected === "acceptable" && libraryAccepts); // you can tweak this logic

    if (!isOk) {
      mismatches.push({
        tcId: tc.tcId,
        comment: tc.comment,
        curve,
        expected,
        libraryAccepts,
        parserAccepts,
        flags: tc.flags,
        derIssues: derStrict.derIssues.map((i) => i.message),
      });
    } else {
      passed++;
    }
  }

  return {
    libraryName,
    curve,
    total: filtered.length,
    passed,
    failed: filtered.length - passed,
    mismatches,
  };
}
3️⃣ Strict + Loose DER Validators
3.1 src/crypto/derStrict.ts – Bitcoin‑style rules
// src/crypto/derStrict.ts
import type { SignatureDerIssue, SighashTypeName } from "../types/txInspector";
import { classifySighashType } from "./sighashTypes";

// secp256k1 order
const curveN = BigInt(
  "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
);
const halfN = curveN >> 1n;

export interface DerStrictResult {
  rHex: string;
  sHex: string;
  isCanonical: boolean;
  rangeValid: boolean;
  isHighS: boolean;
  sighashType?: number;
  sighashName?: SighashTypeName;
  derIssues: SignatureDerIssue[];
  warnings: string[];
}

/**
 * Strict DER validation as per Bitcoin/Core:
 *  - SEQUENCE 0x30
 *  - Correct length
 *  - INTEGER R/S, minimal encoding
 *  - No trailing garbage
 *  - R,S in [1, n-1]
 */
export function analyzeDerStrict(
  sigWithOptionalSighashHex: string
): DerStrictResult {
  const issues: SignatureDerIssue[] = [];
  const warnings: string[] = [];

  let rHex = "";
  let sHex = "";
  let isCanonical = true;
  let rangeValid = true;
  let isHighS = false;
  let sighashType: number | undefined;
  let sighashName: SighashTypeName | undefined;

  try {
    const full = Buffer.from(sigWithOptionalSighashHex, "hex");

    // Assume last byte is sighash type if length >= 9x
    if (full.length > 9) {
      sighashType = full[full.length - 1];
    }

    const sig = sighashType !== undefined ? full.slice(0, -1) : full;

    if (sig[0] !== 0x30) {
      isCanonical = false;
      issues.push({
        code: "BAD_SEQ_TAG",
        message: "Signature does not start with 0x30 (SEQUENCE)",
      });
    }

    const totalLen = sig[1];
    if (totalLen + 2 !== sig.length) {
      isCanonical = false;
      issues.push({
        code: "BAD_LENGTH",
        message: "SEQUENCE length mismatch",
      });
    }

    let offset = 2;

    // R
    if (sig[offset] !== 0x02) {
      isCanonical = false;
      issues.push({
        code: "BAD_LENGTH",
        message: "R INTEGER does not start with 0x02",
      });
    }
    offset++;
    const lenR = sig[offset++];
    const rBytes = sig.slice(offset, offset + lenR);
    offset += lenR;

    // S
    if (sig[offset] !== 0x02) {
      isCanonical = false;
      issues.push({
        code: "BAD_LENGTH",
        message: "S INTEGER does not start with 0x02",
      });
    }
    offset++;
    const lenS = sig[offset++];
    const sBytes = sig.slice(offset, offset + lenS);
    offset += lenS;

    if (offset !== sig.length) {
      isCanonical = false;
      issues.push({
        code: "TRAILING_GARBAGE",
        message: "Trailing data after S INTEGER",
      });
    }

    // Minimal encoding: no unnecessary leading zeros
    if (rBytes.length > 1 && rBytes[0] === 0x00 && (rBytes[1] & 0x80) === 0) {
      isCanonical = false;
      issues.push({
        code: "EXTRA_PADDING_R",
        message: "Unnecessary leading zero in R",
      });
    }
    if (sBytes.length > 1 && sBytes[0] === 0x00 && (sBytes[1] & 0x80) === 0) {
      isCanonical = false;
      issues.push({
        code: "EXTRA_PADDING_S",
        message: "Unnecessary leading zero in S",
      });
    }

    rHex = rBytes.toString("hex");
    sHex = sBytes.toString("hex");

    const r = BigInt("0x" + rHex);
    const s = BigInt("0x" + sHex);

    if (r <= 0n || r >= curveN) {
      rangeValid = false;
      issues.push({
        code: "OUT_OF_RANGE_R",
        message: "R is not in [1, n-1]",
      });
    }
    if (s <= 0n || s >= curveN) {
      rangeValid = false;
      issues.push({
        code: "OUT_OF_RANGE_S",
        message: "S is not in [1, n-1]",
      });
    }

    isHighS = s > halfN;
    if (isHighS) {
      warnings.push("High-S value (non-canonical under BIP62)");
    }

    if (sighashType !== undefined) {
      sighashName = classifySighashType(sighashType);
    }
  } catch (e: any) {
    isCanonical = false;
    warnings.push("DER parse error: " + e.message);
  }

  return {
    rHex,
    sHex,
    isCanonical,
    rangeValid,
    isHighS,
    sighashType,
    sighashName,
    derIssues: issues,
    warnings,
  };
}
3.2 src/crypto/derLoose.ts – emulate legacy “too tolerant” parsers
// src/crypto/derLoose.ts
/**
 * Loose ASN.1-ish parser that:
 *  - allows extra padding
 *  - allows length mismatches
 *  - ignores trailing garbage
 * This is to emulate OpenSSL / old elliptic behavior.
 */

export interface DerLooseResult {
  ok: boolean;
  rHex: string;
  sHex: string;
  error?: string;
}

export function parseDerLoose(sigHex: string): DerLooseResult {
  try {
    const buf = Buffer.from(sigHex, "hex");

    if (buf[0] !== 0x30) {
      // accept wrong tag anyway, just slice
    }
    // naive: try to find first 0x02, treat next as R, second 0x02 as S
    let firstInt = buf.indexOf(0x02, 2);
    if (firstInt < 0) throw new Error("No R integer tag (0x02) found");
    let lenR = buf[firstInt + 1];
    const rBytes = buf.slice(firstInt + 2, firstInt + 2 + lenR);

    const secondInt = buf.indexOf(0x02, firstInt + 2 + lenR);
    if (secondInt < 0) throw new Error("No S integer tag (0x02) found");
    let lenS = buf[secondInt + 1];
    const sBytes = buf.slice(secondInt + 2, secondInt + 2 + lenS);

    return {
      ok: true,
      rHex: rBytes.toString("hex"),
      sHex: sBytes.toString("hex"),
    };
  } catch (e: any) {
    return { ok: false, rHex: "", sHex: "", error: e.message };
  }
}
4️⃣ Library adapters – src/integrations/ellipticAdapter.ts
Standard interface to plug in elliptic, noble, etc.

// src/integrations/ellipticAdapter.ts
import { ec as EC } from "elliptic";

export interface LibraryVerifyParams {
  curve: string;     // "secp256k1", "secp521r1", ...
  msgHashHex: string;
  derHex: string;    // DER (with or without sighash, but you decide convention)
  pubkeyHex: string;
}

export type LibraryVerifyFn = (params: LibraryVerifyParams) => Promise<boolean>;

/**
 * Create an adapter around elliptic's ec("secp256k1") instance.
 * You can have multiple versions by resolving different node_modules or bundling.
 */
export function makeEllipticVerifyAdapter(ecInstance: EC): LibraryVerifyFn {
  return async ({ curve, msgHashHex, derHex, pubkeyHex }) => {
    // curve param is currently ignored, we assume ecInstance matches it
    const msg = Buffer.from(msgHashHex, "hex");
    const sig = Buffer.from(derHex, "hex");
    const key = ecInstance.keyFromPublic(pubkeyHex, "hex");

    try {
      const ok = key.verify(msg, sig);
      return ok === true;
    } catch {
      return false;
    }
  };
}

/**
 * Example adapter for noble-secp256k1, if you use it.
 */
// import * as nobleSecp from "@noble/secp256k1";
// export function makeNobleVerifyAdapter(): LibraryVerifyFn {
//   return async ({ curve, msgHashHex, derHex, pubkeyHex }) => {
//     if (curve !== "secp256k1") return false;
//     const msg = Buffer.from(msgHashHex, "hex");
//     const sig = Buffer.from(derHex, "hex");
//     const pub = Buffer.from(pubkeyHex, "hex");
//     try {
//       return nobleSecp.verify(sig, msg, pub);
//     } catch {
//       return false;
//     }
//   };
// }
You can now feed any adapter into:

runCve42461Suite

runWycheproofSuite

5️⃣ Malleability Playground Engine – src/engines/malleabilityPlayground.ts
Generate canonical + CVE‑style signatures for a given DER.

// src/engines/malleabilityPlayground.ts
import { analyzeDerStrict } from "../crypto/derStrict";
import type { CveEncodingType } from "./cve42461";

export interface MalleabilityVariant {
  id: string;
  encodingType: CveEncodingType;
  derHex: string;
}

/**
 * High-level: given a canonical DER, generate:
 *  - canonical
 *  - extra zero before R
 *  - extra zero before S
 *  - both padded
 *  - length-mismatch (len too big or too small)
 *  - wrong SEQ tag
 *  - trailing garbage
 */
export function generateCveStyleVariants(canonicalDerHex: string): MalleabilityVariant[] {
  const base = Buffer.from(canonicalDerHex, "hex");
  const variants: MalleabilityVariant[] = [];

  // 0) canonical
  variants.push({
    id: "canonical",
    encodingType: "canonical",
    derHex: base.toString("hex"),
  });

  // parse positions of R/S using strict analyzer (for offsets)
  const strict = analyzeDerStrict(canonicalDerHex);
  if (!strict.isCanonical) {
    // still generate some naive variants, but ideally canonical input
  }
  const buf = Buffer.from(canonicalDerHex, "hex");

  // helper to clone
  const clone = () => Buffer.from(buf);

  // 1) BER-padding-r
  variants.push({
    id: "ber-pad-r",
    encodingType: "BER-padding-r",
    derHex: addLeadingZeroToR(buf).toString("hex"),
  });

  // 2) BER-padding-s
  variants.push({
    id: "ber-pad-s",
    encodingType: "BER-padding-s",
    derHex: addLeadingZeroToS(buf).toString("hex"),
  });

  // 3) BER-padding-both
  variants.push({
    id: "ber-pad-both",
    encodingType: "BER-padding-both",
    derHex: addLeadingZeroToS(addLeadingZeroToR(buf)).toString("hex"),
  });

  // 4) BER-length-mismatch (increase SEQ length by 1)
  {
    const b = clone();
    if (b.length > 2) {
      b[1] = b[1] + 1; // incorrect length
    }
    variants.push({
      id: "ber-length",
      encodingType: "BER-length-mismatch",
      derHex: b.toString("hex"),
    });
  }

  // 5) wrong-seq-tag
  {
    const b = clone();
    b[0] = 0x31; // SET
    variants.push({
      id: "wrong-seq-tag",
      encodingType: "wrong-seq-tag",
      derHex: b.toString("hex"),
    });
  }

  // 6) trailing garbage
  {
    const b = Buffer.concat([clone(), Buffer.from("deadbeef", "hex")]);
    variants.push({
      id: "trailing-garbage",
      encodingType: "trailing-garbage",
      derHex: b.toString("hex"),
    });
  }

  return variants;
}

// Helpers: modify R/S length+value in a naive ASN.1 way

function addLeadingZeroToR(buf: Buffer): Buffer {
  const out = Buffer.from(buf);
  // find first INTEGER (R)
  let offset = 2;
  if (out[offset] !== 0x02) return out;
  offset++;
  const lenR = out[offset];
  out[offset] = lenR + 1;
  const before = out.slice(0, offset + 1);
  const rBytes = out.slice(offset + 1, offset + 1 + lenR);
  const after = out.slice(offset + 1 + lenR);
  return Buffer.concat([before, Buffer.from([0x00]), rBytes, after]);
}

function addLeadingZeroToS(buf: Buffer): Buffer {
  const out = Buffer.from(buf);
  // first INTEGER (R)
  let offset = 2;
  if (out[offset] !== 0x02) return out;
  offset++;
  const lenR = out[offset];
  offset += 1 + lenR;

  // second INTEGER (S)
  if (out[offset] !== 0x02) return out;
  offset++;
  const lenS = out[offset];
  out[offset] = lenS + 1;
  const before = out.slice(0, offset + 1);
  const sBytes = out.slice(offset + 1, offset + 1 + lenS);
  const after = out.slice(offset + 1 + lenS);
  return Buffer.concat([before, Buffer.from([0x00]), sBytes, after]);
}
6️⃣ UI Panels – structure only (React)
6.1 CVE Panel – src/ui/Cve42461Panel.tsx
// src/ui/Cve42461Panel.tsx
import React, { useState } from "react";
import { runCve42461Suite } from "../engines/cve42461";
import { makeEllipticVerifyAdapter } from "../integrations/ellipticAdapter";
import { ec as EC } from "elliptic";

const secp = new EC("secp256k1"); // you can parameterize version

export const Cve42461Panel: React.FC = () => {
  const [libraryName, setLibraryName] = useState("elliptic@6.5.x");
  const [msgHashHex, setMsgHashHex] = useState("");
  const [derHex, setDerHex] = useState("");
  const [pubkeyHex, setPubkeyHex] = useState("");
  const [result, setResult] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleRun() {
    setError(null);
    setResult(null);

    if (!msgHashHex || !derHex || !pubkeyHex) {
      setError("Fill msg hash, DER signature, and pubkey.");
      return;
    }

    try {
      setLoading(true);
      const verifyFn = makeEllipticVerifyAdapter(secp);
      const report = await runCve42461Suite({
        libraryName,
        curve: "secp256k1",
        msgHashHex: msgHashHex.trim(),
        canonicalDerHex: derHex.trim(),
        pubkeyHex: pubkeyHex.trim(),
        verifyFn,
      });
      setResult(report);
    } catch (e: any) {
      setError(e.message || "Error running CVE suite");
    } finally {
      setLoading(false);
    }
  }

  return (
    <section>
      <h2>CVE‑2024‑42461 Library Check</h2>
      <div>
        <label>Library</label>
        <select
          value={libraryName}
          onChange={(e) => setLibraryName(e.target.value)}
        >
          <option value="elliptic@6.5.x">elliptic@6.5.x</option>
          {/* Add others: noble, bitcoinjs, HW wallet, etc. */}
        </select>
      </div>

      <div>
        <label>Message Hash (hex)</label>
        <input
          value={msgHashHex}
          onChange={(e) => setMsgHashHex(e.target.value)}
          placeholder="32-byte SHA256 or double-SHA256 hash"
        />
      </div>
      <div>
        <label>Canonical DER Signature (hex)</label>
        <textarea
          rows={3}
          value={derHex}
          onChange={(e) => setDerHex(e.target.value)}
        />
      </div>
      <div>
        <label>Public Key (hex, compressed)</label>
        <input
          value={pubkeyHex}
          onChange={(e) => setPubkeyHex(e.target.value)}
        />
      </div>

      <button disabled={loading} onClick={handleRun}>
        {loading ? "Running tests…" : "Run BER/DER Tests"}
      </button>

      {error && <div className="error">{error}</div>}

      {result && (
        <div className="report">
          <h3>Result for {result.libraryName}</h3>
          <p>
            Canonical accepted:{" "}
            {result.acceptsCanonicalDER ? "✅" : "❌ (broken implementation)"}
          </p>
          <p>
            Non-canonical BER accepted:{" "}
            {result.acceptsBERVariants ? "❌ vulnerable" : "✅ safe"}
          </p>

          <table>
            <thead>
              <tr>
                <th>Id</th>
                <th>Encoding</th>
                <th>Should verify</th>
                <th>Did verify</th>
                <th>Error</th>
              </tr>
            </thead>
            <tbody>
              {result.testCases.map((tc: any) => (
                <tr key={tc.id}>
                  <td>{tc.id}</td>
                  <td>{tc.encodingType}</td>
                  <td>{String(tc.shouldVerify)}</td>
                  <td>{String(tc.didVerify)}</td>
                  <td>{tc.error || ""}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </section>
  );
};
6.2 Wycheproof Lab – src/ui/WycheproofLab.tsx
Skeleton; you’ll wire actual JSON loading via API or bundling.

// src/ui/WycheproofLab.tsx
import React, { useState } from "react";
import { runWycheproofSuite } from "../engines/wycheproofRunner";
import { makeEllipticVerifyAdapter } from "../integrations/ellipticAdapter";
import { ec as EC } from "elliptic";

const secp = new EC("secp256k1");

export const WycheproofLab: React.FC = () => {
  const [curve, setCurve] = useState<"secp256k1" | "secp521r1">("secp256k1");
  const [libraryName, setLibraryName] = useState("elliptic");
  const [filterMode, setFilterMode] =
    useState<"all" | "edge">("edge");
  const [summary, setSummary] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleRun() {
    setError(null);
    setSummary(null);

    try {
      setLoading(true);

      // TODO: fetch or import JSON for chosen curve
      // const json = await fetch(`/wycheproof/${curve}.json`).then(r => r.json());
      const json = {}; // placeholder
      const { mapRawWycheproofJson } = await import(
        "../engines/wycheproofRunner"
      );
      const cases = mapRawWycheproofJson(json, curve);

      const verifyFn = makeEllipticVerifyAdapter(secp);

      const summaryResult = await runWycheproofSuite(cases, {
        curve,
        libraryName,
        verifyFn,
        filter:
          filterMode === "edge"
            ? (tc) => tc.flags.length > 0
            : undefined,
      });

      setSummary(summaryResult);
    } catch (e: any) {
      setError(e.message || "Wycheproof run failed");
    } finally {
      setLoading(false);
    }
  }

  return (
    <section>
      <h2>Wycheproof Test Lab</h2>
      <div>
        <label>Curve</label>
        <select
          value={curve}
          onChange={(e) =>
            setCurve(e.target.value as "secp256k1" | "secp521r1")
          }
        >
          <option value="secp256k1">secp256k1 (Bitcoin)</option>
          <option value="secp521r1">secp521r1</option>
        </select>
      </div>

      <div>
        <label>Library</label>
        <select
          value={libraryName}
          onChange={(e) => setLibraryName(e.target.value)}
        >
          <option value="elliptic">elliptic</option>
          {/* add more */}
        </select>
      </div>

      <div>
        <label>Cases</label>
        <select
          value={filterMode}
          onChange={(e) => setFilterMode(e.target.value as any)}
        >
          <option value="all">All test vectors</option>
          <option value="edge">Only edge-case / malformed</option>
        </select>
      </div>

      <button disabled={loading} onClick={handleRun}>
        {loading ? "Running Wycheproof…" : "Run Wycheproof Suite"}
      </button>

      {error && <div className="error">{error}</div>}

      {summary && (
        <div>
          <h3>
            {summary.libraryName} on {summary.curve}
          </h3>
          <p>
            Passed {summary.passed} / {summary.total}, failed{" "}
            {summary.failed}
          </p>

          {summary.mismatches.length > 0 && (
            <>
              <h4>Mismatches</h4>
              <table>
                <thead>
                  <tr>
                    <th>tcId</th>
                    <th>Expected</th>
                    <th>Lib Accepts</th>
                    <th>Parser Accepts</th>
                    <th>Flags</th>
                    <th>DER Issues</th>
                  </tr>
                </thead>
                <tbody>
                  {summary.mismatches.map((m: any) => (
                    <tr key={m.tcId}>
                      <td>{m.tcId}</td>
                      <td>{m.expected}</td>
                      <td>{String(m.libraryAccepts)}</td>
                      <td>{String(m.parserAccepts)}</td>
                      <td>{m.flags.join(", ")}</td>
                      <td>{m.derIssues.join("; ")}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </>
          )}
        </div>
      )}
    </section>
  );
};
7️⃣ CI – .github/workflows/security-tests.yml
Run Wycheproof & CVE regression as part of CI.

# .github/workflows/security-tests.yml
name: Security & Malleability Tests

on:
  push:
    branches: [ main, master ]
  pull_request:

jobs:
  security-tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install deps
        run: npm ci

      - name: Run unit tests
        run: npm test

      - name: Run Wycheproof ECDSA suites
        run: npm run test:wycheproof
        # script: node ./scripts/runWycheproofAll.js

      - name: Run CVE-2024-42461 regression
        run: npm run test:cve42461
        # script: node ./scripts/runCve42461Regression.js
You’d then add (for example):

scripts/runWycheproofAll.ts → uses runWycheproofSuite over all curves/libraries you care about.

scripts/runCve42461Regression.ts → loads a small JSON of canonical+BER signatures and asserts that your reference implementations behave correctly.

8️⃣ Multi‑curve mode wiring
To support secp521r1, etc.:

In derStrict.ts, keep range checks generic:

Accept curveN as a parameter if you want. For now, you can keep a dictionary:

// src/crypto/curveParams.ts
export const curveOrders: Record<string, bigint> = {
  secp256k1: BigInt("0xfffff...64141"),
  secp521r1: BigInt(
    "0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  ),
};
Modify analyzeDerStrict to accept curve and pick n accordingly.

In runWycheproofSuite, pass the curve name so derStrict can use correct n.

That’s the full set of pipelines and skeletons, wired coherently:

CVE panel engine → runCve42461Suite

Wycheproof engine → runWycheproofSuite

Strict/loose DER validators → derStrict / derLoose

Library adapters → ellipticAdapter

Malleability variant generator → malleabilityPlayground

React UI panels for CVE & Wycheproof

CI workflow to enforce this on every push
import { cryptoAnalysis } from './crypto';
import { bitcoinService } from './bitcoin';
import { storage } from '../storage';

interface VulnerabilityAnalysis {
  vulnerabilities: Array<{
    type: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    description: string;
    affectedTransactions: string[];
    recoveredData?: any;
    educational: boolean;
  }>;
  signatureAnalysis: {
    totalSignatures: number;
    uniqueRValues: number;
    weakPatterns: any[];
    entropyAnalysis: any;
  };
  nonceReuse: Array<{
    rValue: string;
    affectedSignatures: any[];
    recoveredPrivateKey?: string;
    confidence: number;
  }>;
  recoveredKeys: Array<{
    privateKey: string;
    format: string;
    method: string;
    confidence: number;
    educational: true;
  }>;
}

class VulnerabilityService {
  async comprehensiveAnalysis(address: string, utxoData: any): Promise<VulnerabilityAnalysis> {
    const vulnerabilities: VulnerabilityAnalysis['vulnerabilities'] = [];
    const nonceReuse: VulnerabilityAnalysis['nonceReuse'] = [];
    const recoveredKeys: VulnerabilityAnalysis['recoveredKeys'] = [];
    let allSignatures: any[] = [];

    try {
      // Extract signatures from UTXOs
      if (utxoData && utxoData.utxos) {
        for (const utxo of utxoData.utxos) {
          try {
            const txDetails = await bitcoinService.getTransactionDetails(utxo.txid);
            if (txDetails && txDetails.inputs) {
              for (const input of txDetails.inputs) {
                if (input.signature) {
                  allSignatures.push({
                    ...input.signature,
                    messageHash: utxo.txid
                  });
                }
              }
            }
          } catch (error) {
            console.warn(`Failed to get transaction details for ${utxo.txid}:`, error);
          }
        }
      }

      // Perform nonce reuse detection
      const nonceReuseResults = cryptoAnalysis.detectNonceReuse(allSignatures);
      for (const result of nonceReuseResults) {
        if (result.isVulnerable) {
          nonceReuse.push({
            rValue: result.signatures[0].r,
            affectedSignatures: result.signatures,
            recoveredPrivateKey: result.recoveredPrivateKey,
            confidence: result.confidence
          });

          if (result.recoveredPrivateKey) {
            recoveredKeys.push({
              privateKey: result.recoveredPrivateKey,
              format: 'hex',
              method: result.method,
              confidence: result.confidence,
              educational: true
            });
          }

          vulnerabilities.push({
            type: 'nonce_reuse',
            severity: 'critical',
            description: `ECDSA nonce reuse detected. Private key can be recovered using mathematical analysis of signature pairs.`,
            affectedTransactions: result.signatures.map(() => 'educational-demo'),
            recoveredData: {
              privateKey: result.recoveredPrivateKey,
              method: result.method,
              rValue: result.signatures[0].r
            },
            educational: true
          });
        }
      }

      // Analyze signature patterns
      const patternAnalysis = cryptoAnalysis.analyzeSignaturePatterns(allSignatures);
      for (const pattern of patternAnalysis.weakPatterns) {
        vulnerabilities.push({
          type: pattern.type,
          severity: pattern.severity,
          description: pattern.description,
          affectedTransactions: pattern.signatures.map(() => 'educational-demo'),
          educational: true
        });
      }

      // Perform lattice analysis
      const latticeResult = cryptoAnalysis.latticeAnalysis(allSignatures);
      if (latticeResult.isVulnerable) {
        vulnerabilities.push({
          type: 'weak_nonce_entropy',
          severity: 'high',
          description: `Weak nonce generation detected. Lattice-based attacks may be possible.`,
          affectedTransactions: allSignatures.map(s => s.txid),
          recoveredData: latticeResult.details,
          educational: true
        });
      }

      // Entropy analysis
      const entropyAnalysis = cryptoAnalysis.analyzeNonceEntropy(allSignatures);
      if (entropyAnalysis.entropyScore < 70) {
        vulnerabilities.push({
          type: 'poor_entropy',
          severity: entropyAnalysis.entropyScore < 50 ? 'critical' : 'high',
          description: `Poor nonce entropy detected. Score: ${entropyAnalysis.entropyScore}/100. ${entropyAnalysis.recommendation}`,
          affectedTransactions: allSignatures.map(s => s.txid),
          recoveredData: {
            entropyScore: entropyAnalysis.entropyScore,
            patterns: entropyAnalysis.patterns
          },
          educational: true
        });
      }

      // Save vulnerability patterns to database
      for (const vuln of vulnerabilities) {
        await storage.saveVulnerabilityPattern({
          patternType: vuln.type,
          severity: vuln.severity,
          description: vuln.description,
          detectionCriteria: {
            address,
            method: 'comprehensive_analysis'
          },
          exampleTransactions: vuln.affectedTransactions,
          educationalContent: this.getEducationalContent(vuln.type)
        });
      }

      const signatureAnalysis = {
        totalSignatures: allSignatures.length,
        uniqueRValues: new Set(allSignatures.map(s => s.r)).size,
        weakPatterns: patternAnalysis.weakPatterns,
        entropyAnalysis
      };

      return {
        vulnerabilities,
        signatureAnalysis,
        nonceReuse,
        recoveredKeys
      };

    } catch (error) {
      console.error('Comprehensive analysis error:', error);
      throw new Error(`Analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async analyzeSignatures(signatures: any[]): Promise<any> {
    try {
      const nonceReuseResults = cryptoAnalysis.detectNonceReuse(signatures);
      const patternAnalysis = cryptoAnalysis.analyzeSignaturePatterns(signatures);
      const entropyAnalysis = cryptoAnalysis.analyzeNonceEntropy(signatures);

      return {
        nonceReuse: nonceReuseResults,
        patterns: patternAnalysis.weakPatterns,
        entropy: entropyAnalysis,
        summary: {
          totalSignatures: signatures.length,
          vulnerableSignatures: nonceReuseResults.filter(r => r.isVulnerable).length,
          riskLevel: this.calculateRiskLevel(nonceReuseResults, patternAnalysis.weakPatterns)
        }
      };
    } catch (error) {
      console.error('Signature analysis error:', error);
      throw new Error(`Signature analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async processBatchAnalysis(batchId: string, broadcast: (data: any) => void): Promise<void> {
    try {
      const batch = await storage.getBatchAnalysis(batchId);
      if (!batch) {
        throw new Error('Batch analysis not found');
      }

      await storage.updateBatchAnalysis(batchId, {
        status: 'running',
        startedAt: new Date()
      });

      const addresses = batch.addresses as string[];
      let processedCount = 0;
      let vulnerabilityCount = 0;

      for (const address of addresses) {
        try {
          // Fetch UTXOs for address
          const utxoData = await bitcoinService.fetchUTXOs(address);
          
          // Perform vulnerability analysis
          const analysis = await this.comprehensiveAnalysis(address, utxoData);
          
          // Save analysis result
          await storage.saveAnalysisResult({
            bitcoinAddress: address,
            networkType: 'mainnet',
            utxoData,
            vulnerabilities: analysis.vulnerabilities,
            signatureAnalysis: analysis.signatureAnalysis,
            nonceReuse: analysis.nonceReuse,
            recoveredKeys: analysis.recoveredKeys
          });

          vulnerabilityCount += analysis.vulnerabilities.length;
          processedCount++;

          // Update progress
          const progress = Math.round((processedCount / addresses.length) * 100);
          await storage.updateBatchAnalysis(batchId, {
            progress,
            processedAddresses: processedCount,
            vulnerabilitiesFound: vulnerabilityCount
          });

          // Broadcast progress update
          broadcast({
            type: 'batch_progress',
            batchId,
            progress,
            processedCount,
            vulnerabilityCount,
            currentAddress: address
          });

          // Rate limiting to avoid overwhelming APIs
          await new Promise(resolve => setTimeout(resolve, 1000));

        } catch (error) {
          console.error(`Failed to analyze address ${address}:`, error);
          // Continue with next address
        }
      }

      // Mark batch as completed
      await storage.updateBatchAnalysis(batchId, {
        status: 'completed',
        completedAt: new Date(),
        progress: 100
      });

      broadcast({
        type: 'batch_completed',
        batchId,
        totalProcessed: processedCount,
        totalVulnerabilities: vulnerabilityCount
      });

    } catch (error) {
      console.error('Batch analysis error:', error);
      
      await storage.updateBatchAnalysis(batchId, {
        status: 'failed'
      });

      broadcast({
        type: 'batch_error',
        batchId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  private calculateRiskLevel(nonceReuse: any[], patterns: any[]): string {
    const criticalVulns = nonceReuse.filter(r => r.isVulnerable).length;
    const highSeverityPatterns = patterns.filter(p => p.severity === 'critical' || p.severity === 'high').length;

    if (criticalVulns > 0) return 'critical';
    if (highSeverityPatterns > 0) return 'high';
    if (patterns.length > 0) return 'medium';
    return 'low';
  }

  private getEducationalContent(vulnerabilityType: string): string {
    const content: Record<string, string> = {
      'nonce_reuse': `
ECDSA Nonce Reuse Vulnerability:

When the same nonce (k) is used to sign two different messages with the same private key, 
an attacker can recover the private key using the following mathematical relationship:

Given two signatures (r₁, s₁) and (r₂, s₂) where r₁ = r₂:
1. Calculate k = (m₁ - m₂) × (s₁ - s₂)⁻¹ mod n
2. Calculate private key = (r × k - m₁) × s₁⁻¹ mod n

Prevention: Use RFC 6979 deterministic nonce generation or ensure proper randomness.
      `,
      'biased_nonce': `
Biased Nonce Vulnerability:

When nonces have predictable patterns or reduced entropy, lattice-based attacks can recover
the private key even without exact nonce reuse. This includes:

- Nonces with leading zeros
- Sequential or arithmetic progressions
- Insufficient entropy sources

Prevention: Use cryptographically secure random number generators and proper entropy sources.
      `,
      'sighash_single': `
SIGHASH_SINGLE Vulnerability:

The SIGHASH_SINGLE signature type can create vulnerabilities when:
- Input index exceeds output count
- Signature malleability attacks
- Transaction replay possibilities

Prevention: Avoid SIGHASH_SINGLE unless absolutely necessary, use SIGHASH_ALL instead.
      `
    };

    return content[vulnerabilityType] || 'Educational content not available for this vulnerability type.';
  }
}

export const vulnerabilityService = new VulnerabilityService();

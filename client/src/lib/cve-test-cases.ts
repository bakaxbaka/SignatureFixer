/**
 * CVE-2024-42461 Test Cases: Formal BER/DER Encodings
 * Based on elliptic.js bug & PR #317 analysis
 * Tests: ASN.1 strictness for signature verification
 */

export interface CVETestCase {
  id: string;
  name: string;
  description: string;
  encoding: 'canonical-der' | 'ber-leading-zero-r' | 'ber-leading-zero-s' | 'ber-leading-zero-both' | 'ber-wrong-seq-tag' | 'ber-wrong-r-tag' | 'ber-wrong-s-tag' | 'ber-manipulated-seq-len' | 'ber-manipulated-r-len' | 'ber-manipulated-s-len' | 'ber-trailing-garbage';
  shouldVerify: boolean; // Expected behavior in strict verifier
  vulnerability: boolean; // True if this exposes CVE-class bug
  details: string;
}

/**
 * Generate formal CVE-2024-42461 test cases from valid (r, s) pair
 */
export function generateCVETestCases(r: string, s: string): CVETestCase[] {
  return [
    {
      id: 'canonical-der',
      name: 'Canonical DER',
      description: 'Standard, strictly-compliant DER encoding',
      encoding: 'canonical-der',
      shouldVerify: true,
      vulnerability: false,
      details: 'Baseline: must verify in any correct implementation',
    },
    {
      id: 'ber-leading-zero-r',
      name: 'Extra Leading Zero in R',
      description: 'R prefixed with unnecessary 0x00 byte (BER, not canonical)',
      encoding: 'ber-leading-zero-r',
      shouldVerify: false,
      vulnerability: true,
      details: 'Loose ASN.1 parser accepts leading zeros; strict parsers reject',
    },
    {
      id: 'ber-leading-zero-s',
      name: 'Extra Leading Zero in S',
      description: 'S prefixed with unnecessary 0x00 byte (BER, not canonical)',
      encoding: 'ber-leading-zero-s',
      shouldVerify: false,
      vulnerability: true,
      details: 'Same as R; tests S-value strictness',
    },
    {
      id: 'ber-leading-zero-both',
      name: 'Extra Leading Zeros in R & S',
      description: 'Both R and S have unnecessary leading zeros',
      encoding: 'ber-leading-zero-both',
      shouldVerify: false,
      vulnerability: true,
      details: 'Double violation; exposes both-value handling',
    },
    {
      id: 'ber-wrong-seq-tag',
      name: 'Wrong Sequence Tag',
      description: 'Sequence tag changed from 0x30 to 0x31',
      encoding: 'ber-wrong-seq-tag',
      shouldVerify: false,
      vulnerability: true,
      details: 'Tag validation: loose parser ignores tag errors',
    },
    {
      id: 'ber-wrong-r-tag',
      name: 'Wrong R Tag',
      description: 'R integer tag changed from 0x02 to 0x03',
      encoding: 'ber-wrong-r-tag',
      shouldVerify: false,
      vulnerability: true,
      details: 'Integer tag strictness; tests type checking',
    },
    {
      id: 'ber-wrong-s-tag',
      name: 'Wrong S Tag',
      description: 'S integer tag changed from 0x02 to 0x03',
      encoding: 'ber-wrong-s-tag',
      shouldVerify: false,
      vulnerability: true,
      details: 'Same as R; tests symmetric tag handling',
    },
    {
      id: 'ber-manipulated-seq-len',
      name: 'Wrong Sequence Length',
      description: 'Sequence length field incremented by 1',
      encoding: 'ber-manipulated-seq-len',
      shouldVerify: false,
      vulnerability: true,
      details: 'Length validation: off-by-one errors expose parsing flaws',
    },
    {
      id: 'ber-manipulated-r-len',
      name: 'Wrong R Length',
      description: 'R length field incremented by 1',
      encoding: 'ber-manipulated-r-len',
      shouldVerify: false,
      vulnerability: true,
      details: 'Nested length validation; tests component-level strictness',
    },
    {
      id: 'ber-manipulated-s-len',
      name: 'Wrong S Length',
      description: 'S length field incremented by 1',
      encoding: 'ber-manipulated-s-len',
      shouldVerify: false,
      vulnerability: true,
      details: 'Tests per-component length validation',
    },
    {
      id: 'ber-trailing-garbage',
      name: 'Trailing Garbage',
      description: 'Random bytes appended after valid DER signature',
      encoding: 'ber-trailing-garbage',
      shouldVerify: false,
      vulnerability: true,
      details: 'Boundary detection: parser ignores trailing data',
    },
  ];
}

/**
 * Encode DER signature with specific BER variant
 */
export function encodeDERVariant(r: string, s: string, variant: CVETestCase['encoding']): string {
  // Ensure r, s are clean hex (no leading 0x)
  r = r.replace(/^0x/i, '');
  s = s.replace(/^0x/i, '');

  // Pad to 64 chars each if needed
  r = r.padStart(64, '0');
  s = s.padStart(64, '0');

  // Helper: encode integer with tag 0x02, optional leading zero
  const encodeInt = (val: string, withLeadingZero: boolean = false, wrongTag: boolean = false) => {
    const tag = wrongTag ? '03' : '02';
    const bytes = withLeadingZero ? '00' + val : val;
    const len = (bytes.length / 2).toString(16).padStart(2, '0');
    return tag + len + bytes;
  };

  // Helper: canonical sequence
  const encodeSeq = (rEnc: string, sEnc: string, wrongTag: boolean = false) => {
    const tag = wrongTag ? '31' : '30';
    const content = rEnc + sEnc;
    const len = (content.length / 2).toString(16).padStart(2, '0');
    return tag + len + content;
  };

  switch (variant) {
    case 'canonical-der':
      return encodeSeq(encodeInt(r), encodeInt(s));

    case 'ber-leading-zero-r':
      return encodeSeq(encodeInt(r, true), encodeInt(s));

    case 'ber-leading-zero-s':
      return encodeSeq(encodeInt(r), encodeInt(s, true));

    case 'ber-leading-zero-both':
      return encodeSeq(encodeInt(r, true), encodeInt(s, true));

    case 'ber-wrong-seq-tag':
      return encodeSeq(encodeInt(r), encodeInt(s), true);

    case 'ber-wrong-r-tag':
      const rWrongTag = '03' + (r.length / 2).toString(16).padStart(2, '0') + r;
      return encodeSeq(rWrongTag, encodeInt(s));

    case 'ber-wrong-s-tag':
      const sWrongTag = '03' + (s.length / 2).toString(16).padStart(2, '0') + s;
      return encodeSeq(encodeInt(r), sWrongTag);

    case 'ber-manipulated-seq-len': {
      const rEnc = encodeInt(r);
      const sEnc = encodeInt(s);
      const content = rEnc + sEnc;
      const len = ((content.length / 2) + 1).toString(16).padStart(2, '0');
      return '30' + len + content;
    }

    case 'ber-manipulated-r-len': {
      const rLen = ((r.length / 2) + 1).toString(16).padStart(2, '0');
      const rEnc = '02' + rLen + r;
      return encodeSeq(rEnc, encodeInt(s));
    }

    case 'ber-manipulated-s-len': {
      const sLen = ((s.length / 2) + 1).toString(16).padStart(2, '0');
      const sEnc = '02' + sLen + s;
      return encodeSeq(encodeInt(r), sEnc);
    }

    case 'ber-trailing-garbage': {
      const canonical = encodeSeq(encodeInt(r), encodeInt(s));
      return canonical + 'deadbeef';
    }

    default:
      return encodeSeq(encodeInt(r), encodeInt(s));
  }
}

/**
 * Library versions to test against
 */
export const LIBRARY_VERSIONS = [
  { id: 'elliptic-6.5.6', name: 'elliptic 6.5.6 (vulnerable)', vulnerable: true },
  { id: 'elliptic-6.5.7', name: 'elliptic 6.5.7+ (patched)', vulnerable: false },
  { id: 'noble-curves', name: 'noble/curves (strict)', vulnerable: false },
  { id: 'bitcoinjs-lib', name: 'bitcoinjs-lib (strict)', vulnerable: false },
  { id: 'libsecp256k1', name: 'libsecp256k1 (strict)', vulnerable: false },
];
